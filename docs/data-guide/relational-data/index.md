---
title: Relationale Daten
description: ''
author: zoinerTejada
ms:date: 02/12/2018
ms.openlocfilehash: fa2fef27f47acadf00cbfc821c7432c07a3947be
ms.sourcegitcommit: 51f49026ec46af0860de55f6c082490e46792794
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/03/2018
---
# <a name="traditional-relational-database-solutions"></a><span data-ttu-id="18381-102">Herkömmliche relationale Datenbanklösungen</span><span class="sxs-lookup"><span data-stu-id="18381-102">Traditional relational database solutions</span></span>

<span data-ttu-id="18381-103">Bei relationalen Daten handelt es sich um Daten, die mit dem relationalen Modell modelliert werden.</span><span class="sxs-lookup"><span data-stu-id="18381-103">Relational data is data modeled using the relational model.</span></span> <span data-ttu-id="18381-104">Bei diesem Modell werden Daten als Tupel ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="18381-104">In this model, data is expressed as tuples.</span></span> <span data-ttu-id="18381-105">Ein *Tupel* ist ein Satz mit Attribut-Wert-Paaren.</span><span class="sxs-lookup"><span data-stu-id="18381-105">A *tuple* is a set of attribute/value pairs.</span></span> <span data-ttu-id="18381-106">Beispiel für ein Tupel: (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span><span class="sxs-lookup"><span data-stu-id="18381-106">For example, a tuple might be (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span></span> <span data-ttu-id="18381-107">Eine Tupelmenge, bei der die Tupel die Attribute gemeinsam nutzen, wird als *Relation* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="18381-107">A set of tuples that all share the same attributes is called a *relation*.</span></span> 

<span data-ttu-id="18381-108">Relationen werden natürlich als Tabellen dargestellt, wobei jedes Tupel in der Tabelle als Zeile verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="18381-108">Relations are naturally represented as tables, where each tuple is exposed as a row in the table.</span></span> <span data-ttu-id="18381-109">Für Zeilen gilt – im Gegensatz zu Tupeln – aber eine explizite Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="18381-109">However, rows have an explicit ordering, unlike tuples.</span></span> <span data-ttu-id="18381-110">Im Datenbankschema sind die Spalten (Überschriften) jeder Tabelle definiert.</span><span class="sxs-lookup"><span data-stu-id="18381-110">The database schema defines the columns (headings) of each table.</span></span> <span data-ttu-id="18381-111">Jede Spalte wird übergreifend für alle Zeilen der Tabelle mit einem Namen und einem Datentyp für alle Werte definiert, die in dieser Spalte gespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="18381-111">Each column is defined with a name and a data type for all values stored in that column across all rows in the table.</span></span>

![Beispiel mit Daten bei Nutzung einer relationalen Datenbank](../images/example-relational.png)

<span data-ttu-id="18381-113">Ein Datenspeicher, in dem Daten nach dem relationalen Modell organisiert sind, wird als relationale Datenbank bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="18381-113">A data store that organizes data using the relational model is referred to as a relational database.</span></span> <span data-ttu-id="18381-114">Die Zeilen einer Tabelle werden mit Primärschlüsseln eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="18381-114">Primary keys uniquely identify rows within a table.</span></span> <span data-ttu-id="18381-115">Fremdschlüsselfelder werden in einer Tabelle verwendet, um auf eine Zeile in einer anderen Tabelle zu verweisen, indem auf den Primärschlüssel der anderen Tabelle verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="18381-115">Foreign key fields are used in one table to refer to a row in another table by referencing the primary key of the other table.</span></span> <span data-ttu-id="18381-116">Fremdschlüssel werden verwendet, um die referentielle Integrität zu wahren und sicherzustellen, dass die referenzierten Zeilen nicht geändert oder gelöscht werden, während die verweisende Zeile davon abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="18381-116">Foreign keys are used to maintain referential integrity, ensuring that the referenced rows are not altered or deleted while the referencing row depends on them.</span></span> 

![Beispiel mit Daten bei Nutzung einer relationalen Datenbank](../images/example-relational2.png)

<span data-ttu-id="18381-118">Relationale Datenbanken unterstützen verschiedene Arten von Einschränkungen, die zur Sicherstellung der Datenintegrität beitragen:</span><span class="sxs-lookup"><span data-stu-id="18381-118">Relational databases support various types of constraints that help to ensure data integrity:</span></span>

- <span data-ttu-id="18381-119">Mit eindeutigen Einschränkungen wird erreicht, dass alle Werte einer Spalte eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="18381-119">Unique constraints ensure that all values in a column are unique.</span></span> 

- <span data-ttu-id="18381-120">Mit Fremdschlüsseleinschränkungen wird eine Verknüpfung zwischen den Daten in zwei Tabellen erzwungen.</span><span class="sxs-lookup"><span data-stu-id="18381-120">Foreign key constraints enforce a link between the data in two tables.</span></span> <span data-ttu-id="18381-121">Ein Fremdschlüssel verweist auf den Primärschlüssel oder einen anderen eindeutigen Schlüssel aus der anderen Tabelle.</span><span class="sxs-lookup"><span data-stu-id="18381-121">A foreign key references the primary key or another unique key from another table.</span></span> <span data-ttu-id="18381-122">Eine Fremdschlüsseleinschränkung erzwingt die referentielle Integrität, und Änderungen, die zu ungültigen Fremdschlüsselwerten führen, werden nicht zugelassen.</span><span class="sxs-lookup"><span data-stu-id="18381-122">A foreign key constraint enforces referential integrity, disallowing changes that cause invalid foreign key values.</span></span>

- <span data-ttu-id="18381-123">CHECK-Einschränkungen, die auch als Integritätseinschränkungen bezeichnet werden, sorgen für eine Begrenzung der Werte, die in einer Spalte oder bezogen auf Werte in anderen Spalten derselben Zeile gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="18381-123">Check constraints, also known as entity integrity constraints, limit the values that can be stored within a single column, or in relationship to values in other columns of the same row.</span></span> 

<span data-ttu-id="18381-124">Für die meisten relationalen Datenbanken wird die Structured Query Language (SQL) verwendet, die einen deklarativen Ansatz für das Durchführen von Abfragen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="18381-124">Most relational databases use the Structured Query Language (SQL) language that enables a declarative approach to querying.</span></span> <span data-ttu-id="18381-125">In der Abfrage wird das gewünschte Ergebnis beschrieben, aber nicht die Schritte zum Ausführen der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="18381-125">The query describes the desired result, but not the steps to execute the query.</span></span> <span data-ttu-id="18381-126">Das Modul wählt dann den besten Weg zum Durchführen der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="18381-126">The engine then decides the best way to execute the query.</span></span> <span data-ttu-id="18381-127">Dies unterscheidet sich von einem prozeduralen Ansatz, bei dem die Verarbeitungsschritte über das Abfrageprogramm explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="18381-127">This differs from a procedural approach, where the query program specifies the processing steps explicitly.</span></span> <span data-ttu-id="18381-128">In relationalen Datenbanken können Routinen mit ausführbarem Code aber in Form von gespeicherten Prozeduren und Funktionen gespeichert werden, sodass eine Mischung von deklarativen und prozeduralen Ansätzen möglich ist.</span><span class="sxs-lookup"><span data-stu-id="18381-128">However, relational databases can store executable code routines in the form of stored procedures and functions, which enables a mixture of declarative and procedural approaches.</span></span>

<span data-ttu-id="18381-129">Zur Verbesserung der Abfrageleistung werden in relationalen Datenbanken *Indizes* verwendet.</span><span class="sxs-lookup"><span data-stu-id="18381-129">To improve query performance, relational databases use *indexes*.</span></span> <span data-ttu-id="18381-130">Mit primären Indizes, die vom Primärschlüssel genutzt werden, wird die Reihenfolge der Daten auf dem Datenträger definiert.</span><span class="sxs-lookup"><span data-stu-id="18381-130">Primary indexes, which are used by the primary key, define the order of the data as it sits on disk.</span></span> <span data-ttu-id="18381-131">Bei sekundären Indizes ist eine andere Kombination von Feldern möglich, sodass die gewünschten Zeilen effizient abgefragt werden können, ohne dass die gesamten Daten auf dem Datenträger neu sortiert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="18381-131">Secondary indexes provide an alternative combination of fields, so the desired rows can be queried efficiently, without having to re-sort the entire data on disk.</span></span>

<span data-ttu-id="18381-132">Da mit relationalen Datenbanken die referentielle Integrität erzwungen wird, kann das Skalieren einer relationalen Datenbank schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="18381-132">Because relational databases enforce referential integrity, scaling a relational database can become challenging.</span></span> <span data-ttu-id="18381-133">Dies liegt daran, dass von jedem Abfrage- oder Einfügevorgang eine große Zahl von Tabellen betroffen sein kann.</span><span class="sxs-lookup"><span data-stu-id="18381-133">That's because any query or insert operation might touch any number of tables.</span></span> <span data-ttu-id="18381-134">Sie können eine relationale Datenbank horizontal hochskalieren, indem Sie für die Daten das *Sharding* durchführen. Hierfür ist aber ein sorgfältiger Schemaentwurf erforderlich.</span><span class="sxs-lookup"><span data-stu-id="18381-134">You can scale out a relational database by *sharding* the data, but this requires careful design of the schema.</span></span> <span data-ttu-id="18381-135">Weitere Informationen finden Sie unter [Sharding-Muster](../../patterns/sharding.md).</span><span class="sxs-lookup"><span data-stu-id="18381-135">For more information, see [Sharding pattern](../../patterns/sharding.md).</span></span>

<span data-ttu-id="18381-136">Wenn Daten nicht relational sind oder über Anforderungen verfügen, die für eine relationale Datenbank nicht geeignet sind, können Sie einen [nicht relationalen oder NoSQL](../big-data/non-relational-data.md)-Datenspeicher verwenden.</span><span class="sxs-lookup"><span data-stu-id="18381-136">If data is non-relational or has requirements that are not suited to a relational database, consider a [Non-relational or NoSQL](../big-data/non-relational-data.md) data store.</span></span>
